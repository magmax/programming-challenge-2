Explicación Challenge 13:

	Para este problema lo primero que se hace es una simulación de una ronda del croupier, con una única simulación nos basta para saber qué elementos quedan en qué posición tras ejecutar una ronda. Para ello creamos un array de N elementos ordenados (0 al N-1) y, al simular, nos queda una tabla x->y (int -> int) que indica que el elemento que estaba en el índice y pasa a estar en el índice x tras una ronda. Esto también se puede interpretar como "para que un elemento esté en la posición x, antes tiene que haber estado en la posición y, ya que de y se mueve a x", entonces se recorre la tabla x->y, y->z... para todos los elementos hasta comprobar cuántos saltos hacen falta para cada elemento esté en su sitio de nuevo, se está recorriendo la tabla al revés: "para que el elemento esté en la posición 0, antes ha tenido que estar en la posición y ... ... para que el elemento esté en la posición z, antes ha tenido que estar en la 0".
	Este diseño se puede mejorar con la idea de que no hace falta comprobar que cada elemento acaba en la posición en la que empieza, basta con encontrar los ciclos ya que todos los movimientos de las rondas son los mismos, es por ello que se lleva un registro de los elementos que han sido comprobados en cada ciclo, para evitar comprobarlos de nuevo. Una vez se tienen todos los saltos que son necesarios para todos los ciclos de la simulación, se calcula el mínimo común múltiplo de todos ellos (en el programa se va calculando según se comprueban los ciclos)
	Cabe destacar que la complejidad del cálculo del mcm de a y b es O(min(a,b)) en el peor caso.


